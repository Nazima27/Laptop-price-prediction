# -*- coding: utf-8 -*-
"""ml_capstone_prjct.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19-FbuevVYztyqEJuZqMFEhQLNHJki1Qp
"""

#Importing all necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings

# To ignore all future warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# Your code here

df = pd.read_csv("/content/laptop.csv") # Reading the dataset

df.head()

df.isnull().sum() # Checking the null values

# Apply a function to each column to fill missing values
df = df.apply(lambda x: x.fillna(x.median()) if x.dtype=='float' else x.fillna(x.value_counts().index[0]))

df.info()

"""# **Data Preprocessing**"""

df = df.drop_duplicates()
df.shape

df.drop(columns="Unnamed: 0.1", axis = 1,inplace = True )# Deleting unwanted columns

df.drop(columns="Unnamed: 0", axis = 1,inplace = True )

import plotly.express as px

px.box(df["Price"])# Checking for the outliers

df.describe()["Price"]

Q1=df.describe()["Price"]["25%"]
Q1

Q3=df.describe()["Price"]["75%"]

IQR=Q3-Q1
IQR

UpperFence=Q3+1.5*IQR

LowerFence = Q1-1.5*IQR

df["Price"]=df["Price"].clip(UpperFence,LowerFence )

df["Weight"].value_counts()

df["TypeName"].value_counts()

df["Ram"].value_counts()

df["OpSys"].value_counts()

categorical = df.select_dtypes(include=['object']).columns
numericals = df.select_dtypes(include = ['int32','int64','float32','float64']).columns
categorical

df["Ram"] = df['Ram'].str.replace("GB", "")

df["Ram"] = df["Ram"].astype("float32")

df["Weight"]= df["Weight"].str.replace("kg","")

# Replace '?' values with 0
df['Weight'].replace('?', 0, inplace=True)

# Convert the 'Weight' column to float32
df['Weight'] = df['Weight'].astype('float32')
df["Weight"]

df.isnull().sum()



"""# **Feature Engineering**"""

df.head()

"""# **PRICE**"""

sns.histplot(df['Price'],kde = True , color = "RED")
plt.show()

sns.barplot(x=df['Ram'], y=df['Price'], palette='plasma')

plt.xticks(rotation="vertical")
plt.title('Ram VS Price')
plt.show()

#what is avg price of each brand?
sns.barplot(x=df['Company'], y=df['Price'], palette='plasma')
plt.title('Company VS Price')
plt.xticks(rotation="vertical")

plt.show()

sns.barplot(x=df["Memory"], y= df["Price"], palette="Spectral")
plt.xticks(rotation= "vertical")
plt.title('Memory VS Price')
plt.show()

sns.barplot(x=df["OpSys"], y= df["Price"], palette="flare")
plt.xticks(rotation= "vertical")
plt.title('Opsys VS Price')
plt.show()

"""# **TypeName**"""

## Type of laptop
sns.barplot(x= df["TypeName"] , y= df["Price"], palette='autumn')
plt.title('TypeName VS Price')
plt.xticks(rotation = "vertical")
plt.show()

plt.figure(figsize=(12,7))
sns.scatterplot(x = df['Inches'],y = df['Price'],color ="red")
plt.title('Inches VS Price')
plt.show()

df.head()

"""**countplots**"""

plt.figure(figsize=(9,7))
sns.countplot(df["Memory"],palette='autumn')
plt.xticks(rotation = 'vertical')
plt.show()

sns.countplot(df["OpSys"],palette="Spectral")
plt.xticks(rotation="vertical")
plt.show()

sns.countplot(df["TypeName"],palette="Spectral")
plt.xticks(rotation="vertical")
plt.show()

sns.countplot(df["Company"],palette="dark:#5A9_r")
plt.show()

# Fetching touchscreen data from screenresolution column
df['Touchscreen'] = df['ScreenResolution'].apply(lambda x: 1 if isinstance(x, str) and 'Touchscreen' in x else 0)

df["Touchscreen"].value_counts()

sns.barplot(df["Touchscreen"].value_counts(),palette="flare")
plt.show()

sns.barplot(x=df["Touchscreen"] , y= df["Price"] , palette="Spectral")
plt.title("Touchscreen VS Price")
plt.show() ##we can see that the price of laptops also depend on Touchscreen

df['Ips'] = df['ScreenResolution'].apply(lambda x: 1 if isinstance(x, str) and 'IPS' in x else 0)
sns.barplot(df["Ips"].value_counts(),palette="flare")
plt.show()

sns.barplot(x=df["Ips"] , y= df["Price"] , palette="dark:#5A9_r")
plt.title("Ips VS Price")
plt.show()

"""# **fetching x & y from the screen column**

"""

res = df['ScreenResolution'].str.split('x', n =1, expand = True)
df["x_res"]= res[0]
df["y_res"] = res[1]
df.head()

df['x_res'] = df['x_res'].astype(str).str.replace(',','').str.extract(r'(\d+\.?\d+)')

# Fill NaN values with 0 in the 'x_res' and 'y_res' columns
df['x_res'].fillna(0, inplace=True)
df['y_res'].fillna(0, inplace=True)

# Convert 'x_res' and 'y_res' columns to integer data type
df['x_res'] = df['x_res'].astype(int)
df['y_res'] = df['y_res'].astype(int)

df.info()

df = df[df["Inches"]!="?"]
df["Inches"]= df["Inches"].astype("float")

df['PPI'] = (((df['x_res']**2+df['y_res']**2))**0.5/df['Inches']).astype('float')

df.drop(columns=['Inches','x_res','y_res'],inplace=True)
df.head()

df.corr()["Price"]

sns.heatmap(df.corr(), vmin=0, vmax=0.8)
plt.show()

df.drop(columns=['ScreenResolution'],inplace=True)
df.head()

df['Cpu'] = df['Cpu'].astype(str)

df['cpu_name'] = df['Cpu'].apply(lambda text: " ".join(text.split()[:3]))

def processortype(text):
    if text == 'Intel Core i7' or text=='Intel Core i5' or text=='Intel Core i3':
        return  text
    else:
        if text.split()[0]=='Intel':
            return 'Other Intel Processor'

        else:
            return 'AMD Processor'

# Apply the function to the 'cpu_name' column
df['cpu_name'] = df['cpu_name'].apply(lambda text: processortype(text))

"""# **CPU**"""

sns.countplot(y=df['cpu_name'],palette='plasma')
plt.title("CPU Count")
plt.xticks(rotation = 'vertical')
plt.show()

sns.barplot(x=df['cpu_name'],y=df['Price'],palette="plasma")
plt.xticks(rotation = 'vertical')
plt.show()

df.drop(columns=['Cpu'],inplace=True)

"""# **Ram**"""

sns.countplot(x=df['Ram'],palette='autumn')
plt.show()

sns.barplot(x=df['Ram'],y=df['Price'],palette="autumn")
plt.show()

"""# **Memory**"""

df['Memory'].iloc[:1][0]

df['Memory'].value_counts()

df['Memory'] = df['Memory'].astype(str).replace('\.0','',regex = True)
df['Memory'] = df['Memory'].str.replace('GB','')
df['Memory'] = df['Memory'].str.replace('TB','000')
newdf = df['Memory'].str.split("+",n = 1,expand = True)
newdf

df['first'] = newdf[0]
df['first'] = df['first'].str.strip()
df.head()

def memorychanges(value):

    df['Layer1'+value] = df['first'].apply(lambda x:1 if value in x else 0)


listtoapply = ['HDD','SSD','Hybrid','FlashStorage']
for value in listtoapply:
    memorychanges(value)

df['first'] = df['first'].str.replace(r'\D','')
df['first'].value_counts()

df['Second'] = newdf[1]

def memorychanges1(value):
     df['Layer2'+value] = df['Second'].apply(lambda x: 1 if value in str(x) else 0)


listtoapply1 = ['HDD','SSD','Hybrid','FlashStorage']
df['Second'] = df['Second'].fillna("0")
for value in listtoapply1:
    memorychanges1(value)

df['first'] = df['first'].str.isdigit()
df['Second'] = df['Second'].str.isdigit()

df["HDD"]=(df["first"]*df["Layer1HDD"]+df["Second"]*df["Layer2HDD"])
df["SSD"]=(df["first"]*df["Layer1SSD"]+df["Second"]*df["Layer2SSD"])
df["Hybrid"]=(df["first"]*df["Layer1Hybrid"]+df["Second"]*df["Layer2Hybrid"])
df["Flash_Storage"]=(df["first"]*df["Layer1FlashStorage"]+df["Second"]*df["Layer2FlashStorage"])

df.drop(columns=['first', 'Second', 'Layer1HDD', 'Layer1SSD', 'Layer1Hybrid',
       'Layer1FlashStorage', 'Layer2HDD', 'Layer2SSD', 'Layer2Hybrid',
       'Layer2FlashStorage'],inplace=True)

df.drop(columns=['Memory'],inplace=True)

df.corr()['Price']

df.drop(columns = ['Hybrid','Flash_Storage'],inplace=True)

"""# **Gpu**"""

df['Gpu'].value_counts()

a = df['Gpu'].iloc[1]
print(a.split()[0])

df['Gpu brand'] = df['Gpu'].apply(lambda x:x.split()[0])
sns.countplot(df['Gpu brand'],palette='plasma')
plt.show()

df = df[df['Gpu brand']!='ARM']
sns.countplot(df['Gpu brand'],palette='plasma')
plt.show()

sns.barplot(x=df['Gpu brand'],y=df['Price'],estimator=np.median,palette="plasma")
plt.show()

df = df.drop(columns=['Gpu'])

df.head()

"""# **Operating System**"""

df['OpSys'].value_counts()

sns.barplot(x=df['OpSys'],y=df['Price'],palette="plasma")
plt.xticks(rotation = 'vertical')
plt.show()

df['OpSys'].unique()

def setcategory(text):

    if text=='Windows 10' or text=='Windows 7' or text=='Windows 10 S':
        return 'Windows'

    elif text=='Mac OS X' or text=='macOS':
        return 'Mac'

    else:
        return 'Other'


df['OpSys'] = df['OpSys'].apply(lambda x:setcategory(x))

sns.countplot(df['OpSys'],palette='plasma')
plt.show()

sns.barplot(x = df['OpSys'],y = df['Price'],palette="autumn")
plt.show()

sns.distplot(df['Weight'],kde=True)
plt.show()

sns.scatterplot(x=df['Weight'],y=df['Price'])
plt.show()

sns.distplot(df['Price'])
plt.show()

sns.distplot(np.log(df['Price']))
plt.show()

sns.heatmap(df.corr(),annot=True,cmap='plasma')
plt.show()

x= df.drop(columns=['Price'],axis = 1)
y= np.log(df["Price"])

df_new=df.copy()

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.15,random_state=2)

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler,StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import LabelEncoder,OneHotEncoder
from sklearn import metrics
from sklearn.model_selection import RandomizedSearchCV
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor,GradientBoostingRegressor
from xgboost import XGBRegressor
from sklearn import tree

mapper = {i:value for i,value in enumerate(x_train.columns)}
mapper

df.head(1)

"""# **LinearRegression**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,3,8,11])
],remainder='passthrough')

step2 = LinearRegression()

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(x_train,y_train)

y_pred = pipe.predict(x_test)

print('R2 score',metrics.r2_score(y_test,y_pred))
print('MAE',metrics.mean_absolute_error(y_test,y_pred))

np.exp(0.21)

"""# **DecisionTree**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,3,8,11])
],remainder='passthrough')

step2 = DecisionTreeRegressor(max_depth=8)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(x_train,y_train)

y_pred = pipe.predict(x_test)

print('R2 score',metrics.r2_score(y_test,y_pred))
print('MAE',metrics.mean_absolute_error(y_test,y_pred))

"""# **RandomForest**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,3,8,11])
],remainder='passthrough')

step2 = RandomForestRegressor(n_estimators=100,
                              random_state=3,
                              max_samples=0.5,
                              max_features=0.75,
                              max_depth=15)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(x_train,y_train)

y_pred = pipe.predict(x_test)

print('R2 score',metrics.r2_score(y_test,y_pred))
print('MAE',metrics.mean_absolute_error(y_test,y_pred))

"""# **XGB**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,3,8,11])
],remainder='passthrough')

step2 =XGBRegressor(n_estimators=45,
                              learning_rate = 0.5,
                              max_depth=5)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(x_train,y_train)

y_pred = pipe.predict(x_test)

print('R2 score',metrics.r2_score(y_test,y_pred))
print('MAE',metrics.mean_absolute_error(y_test,y_pred))

"""## **GradientBoost**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,3,8,11])
],remainder='passthrough')

step2 =GradientBoostingRegressor(n_estimators=500)


pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(x_train,y_train)

y_pred = pipe.predict(x_test)

print('R2 score',metrics.r2_score(y_test,y_pred))
print('MAE',metrics.mean_absolute_error(y_test,y_pred))

import pickle
pickle.dump(pipe,open("LaptopPricePrediction.pkl",'wb'))
